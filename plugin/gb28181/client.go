package plugin_gb28181

import (
	"context"
	"fmt"
	"net"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/emiago/sipgo"
	"github.com/emiago/sipgo/sip"
	"github.com/icholy/digest"
	"github.com/rs/zerolog"
	"m7s.live/v5/pkg/task"
)

type Client struct {
	*sipgo.Client
	task.Job
	conf *GB28181Plugin
}

type KeepAlive struct {
	task.Task
	client *Client
}

func (c *Client) Start() (err error) {
	netWork, parent, _ := strings.Cut(c.conf.Parent, ":")
	host, portStr, _ := net.SplitHostPort(parent)
	if portStr != "" {
		portStr = "5060"
	}
	port, _ := strconv.Atoi(portStr)
	c.Client, err = sipgo.NewClient(c.conf.ua, sipgo.WithClientLogger(zerolog.New(os.Stdout)), sipgo.WithClientHostname(host), sipgo.WithClientPort(port))
	if err != nil {
		return
	}
	recipient := sip.Uri{}
	sip.ParseUri(fmt.Sprintf("sip:%s@%s", c.conf.Serial, c.conf.Realm), &recipient)
	req := sip.NewRequest("REGISTER", recipient)
	req.AppendHeader(
		sip.NewHeader("Contact", fmt.Sprintf("<sip:%s@%s>", c.conf.Serial, c.conf.Realm)),
	)
	req.SetTransport(strings.ToUpper(netWork))
	var res *sip.Response
	res, err = c.Do(c.conf, req)
	if err != nil {
		c.conf.Error("register", "error", err.Error())
	} else {
		c.conf.Info("register", "response", res.String())
		if res.StatusCode == 401 {
			// Get WwW-Authenticate
			wwwAuth := res.GetHeader("WWW-Authenticate")
			var chal *digest.Challenge
			chal, err = digest.ParseChallenge(wwwAuth.Value())
			if err != nil {
				c.conf.Error("register", "error", err.Error())
			}

			// Reply with digest
			cred, _ := digest.Digest(chal, digest.Options{
				Method:   req.Method.String(),
				URI:      recipient.Host,
				Username: c.conf.Username,
				Password: c.conf.Password,
			})

			newReq := req.Clone()
			newReq.RemoveHeader("Via") // Must be regenerated by tranport layer
			newReq.AppendHeader(sip.NewHeader("Authorization", cred.String()))

			ctx := context.Background()
			var tx sip.ClientTransaction
			tx, err = c.TransactionRequest(ctx, newReq, sipgo.ClientRequestAddVia)
			if err != nil {
				c.conf.Error("register", "error", err.Error())
			}
			defer tx.Terminate()

			res, err = getResponse(tx)
			if err != nil {
				c.conf.Error("register", "error", err.Error())
				return
			}
		}
		var ka KeepAlive
		ka.client = c
		ka.SetRetry(-1, time.Second*10)
		c.AddTask(&ka)
	}
	return
}

func getResponse(tx sip.ClientTransaction) (*sip.Response, error) {
	select {
	case <-tx.Done():
		return nil, fmt.Errorf("transaction died")
	case res := <-tx.Responses():
		return res, nil
	}
}

func (c *Client) Run() (err error) {
	return
}
